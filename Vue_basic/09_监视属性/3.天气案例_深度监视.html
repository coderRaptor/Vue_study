<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>天气案例_深度监视</title>
    <script src="../js/vue.js"></script>
</head>

<body>
    <!-- 
        深度监视:
            (1).Vue中的watch默认不检测对象内部属性值的改变(一层)
            (2).配置deep:true(默认false)可以检测对象(数组不行)内部值改变(多层)
        备注:
            (1).Vue自身可以检测对象内部值的改变,但Vue提供的watch默认不可以,即immediate:false
            (2).使用watch时根据数据的具体结构,决定是否采用深度监视
            (3).数组也是特殊的对象,但是这里数组无法监视并且数组内部元素变化不会引起模板的更新但实际变了,还未得知原因,往后学习后会补充
        补充: 并不是说 JS 不能支持响应式数组，其实JS是没有这种限制的。
              数组在 JS 中常被当作栈，队列，集合等数据结构的实现方式，会有批量的数据以待遍历。并且 runtime 对对象与数组的优化也有所不同。
              所以对数组的处理需要特化出来以提高性能。
              Vue 中是通过对每个键设置 getter/setter 来实现响应式的，开发者使用数组，目的往往是遍历，此时调用 getter 开销太大了，所以 Vue 不在数组每个键上设置，而是在数组上定义 __ob__ ，并且替换了 push 等等能够影响原数组的原型方法。
              为此也有人去GitHub问了尤大，他的回答也是说因为性能问题而没有采用这种方式监听数组。
              vm.$set可以检测数值,采用了另外方式处理数组
              链接：https://juejin.cn/post/6918652111542714381
              来源：稀土掘金

        后续学习补充: 因此想要能够监视到数组的变化必须通过Vue.set或vm.$set改变数组实现数组响应式,
                        或者通过调用重写(重写了能够改变原数组)的数组api
    -->
    <div id="root">
        <h2>今天天气很{{info}}</h2>
        <button @click="changeWeather">切换天气</button>
        <hr>
        <h3>a的值是:{{numbers.a}}</h3>
        <button @click="numbers.a++">点我让a+1</button>
        <h3>b的值是:{{numbers.b}}</h3>
        <button @click="numbers.b++">点我让b+1</button>
        <h3>k的值是:{{arr[0]}}</h3>
        <button @click="arr[0] += 1">点我让k+1</button>
        <button @click="numbers = {a: 888, b: 999}">彻底替换调numbers</button>
    </div>
    <script>
        Vue.config.productionTip = false;
        const vm = new Vue({
            el: "#root",
            data: {
                isHot: true,
                numbers: {
                    a: 1,
                    b: 1
                },
                arr: [1, 2],
            },
            methods: {
                changeWeather() {
                    this.isHot = !this.isHot;
                }
            },
            computed: {
                info() {
                    return this.isHot ? '炎热' : '凉爽';
                }
            },
            watch: {
                // 计算属性一样可以监视
                isHot: {
                    // immediate:true, //初始化时是否让handler调用一下,不写默认为false
                    // handler什么时候被调用? 当isHot发生改变时
                    handler(val, oldVal) {
                        console.log("isHot被修改了", val, oldVal);
                    }
                },
                numbers: {
                    deep: true, // 默认false
                    handler(val, oldVal) {
                        console.log("number内部属性被修改了", val, oldVal);
                    }
                },

                // 失效
                arr: {
                    // deep:true,
                    handler(val, oldVal) {
                        console.log("arr内部元素被修改了", val, oldVal);
                    }
                }
            }
        })
    </script>

</body>

</html>